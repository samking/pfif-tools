#!/usr/bin/env python
# Copyright 2011 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Displays the difference between two PFIF XML files.

* Differences in field order are ignored regardless of PFIF version.
* Notes that are children of persons automatically have the person_record_id
  added to them, so children of persons and top-level notes are considered the
  same.
* This tool assumes that both files are valid PFIF XML.  That means that this
  tool is not guaranteed to notice if, for instance, one file has a child of the
  root that is neither a person nor a note and the other child is missing that
  or if there are two notes with the same note_record_id.
* The output will include one message per person or note that is missing or
  added.  These messages will specify whether it is a person or note and whether
  it was missing or added in addition to the id of the note.  The output will
  also include one message per person or note field that is missing, added, or
  changed.  For each of these, it will display the id of the containing person
  or note, the field name, whether the field was missing, added, or changed, the
  current text (if present), and the expected text (if present)."""

__author__ = 'samking@google.com (Sam King)'

import utils

# TODO(samking): Add --ignore-field flag.  Add --blank-is-nonexistent flag.

# To allow person_record_ids and note_record_ids (which could be the same) to
# reside in the same map, we need to make them unique.
PERSON_PREFIX = 'p'
NOTE_PREFIX = 'n'

def record_id_to_key(record_id, is_person):
  """Call this method on a record_id to turn the record id into a key for the
  object generated by objectify_pfif_xml.  This must be done to allow both
  notes and persons to reside in the same map."""
  if is_person:
    return PERSON_PREFIX + record_id
  else:
    return NOTE_PREFIX + record_id

def change_record_ids(reference_map):
  """Call this method on a map to transform all keys as per record_id_to_key.
  This can change a reference map into a map suitable for comparison with a map
  generated by objectify_pfif_xml."""
  transformed_object = {}
  for record_id, record_map in reference_map.items():
    is_person = 'person' in record_id
    transformed_key = record_id_to_key(record_id, is_person)
    transformed_object[transformed_key] = record_map
  return transformed_object


def objectify_parents(parents, is_person, object_map, tree,
                      parent_person_record_id=None):
  """Adds the object representation of each parent in parents to object_map.
  If is_person, all parents are assumed to be persons (else, notes).  Tree is
  a PfifXmlTree.  Specifying parent_person_record_id is used for recursive
  calls when a person has a note as a child."""
  if is_person:
    record_id_tag = 'person_record_id'
  else:
    record_id_tag = 'note_record_id'
  for parent in parents:
    record_id = tree.get_field_text(parent, record_id_tag)
    # TODO(samking): what should we do here?  Silently ignore, print a
    # warning, or assert?
    assert record_id is not None, ('Invalid PFIF XML: a record is missing '
                                   'its ' + record_id_tag + ' field.')
    record_map = object_map.setdefault(
        record_id_to_key(record_id, is_person), {})
    # If this note is a child of a person, it isn't required to have a
    # person_record_id, but it's easier to deal with notes that have
    # person_record_ids, so we force-add it.
    if not is_person and parent_person_record_id is not None:
      record_map['person_record_id'] = parent_person_record_id
    for child in parent.getchildren():
      field_name = utils.extract_tag(child.tag)
      # We'll deal with all notes together, so skip them for now.
      if is_person and field_name == 'note':
        continue
      else:
        field_value = child.text
        record_map[field_name] = field_value
    if is_person:
      sub_notes = parent.findall(tree.add_namespace_to_tag('note'))
      objectify_parents(sub_notes, False, object_map, tree,
                        parent_person_record_id=record_id)

def objectify_pfif_xml(file_to_objectify):
  """Turns a file of PFIF XML into a map."""
  # read the file into an XML tree
  tree = utils.PfifXmlTree(file_to_objectify)
  # turn the xml trees into a persons and notes map for each file.  They will
  # map from record_id to a map from field_name to value
  object_map = {}
  objectify_parents(tree.get_all_persons(), True, object_map, tree)
  objectify_parents(tree.get_top_level_notes(), False, object_map, tree)
  return object_map

def pfif_obj_diff(records_1, records_2):
  """Compares if records_1 and records_2 contain the same data.  Returns a
  list of messages containing one message for each of the following scenarios:
   * Missing Records: records_1 contains a record that is not in records_2,
   * Extra Records: records_2 contains a record that is not in records_1,
   * Missing Fields: a record in records_1 contains a field that is not in the
     corresponding record in records_2
   * Extra Fields: a record in records_2 contains a field that is not in the
     corresponding record in records_1
   * Different Values: a field value in records_1 is not the same as the
     corresponding field value in records_2"""
  messages = []
  for record, field_map_1 in records_1.items():
    field_map_2 = records_2.get(record)
    # Are there any missing records?
    if field_map_2 is None:
      messages.append('missing record')
    else:
      for field, value_1 in field_map_1.items():
        value_2 = field_map_2.get(field)
        # Are there any missing fields?
        if value_2 is None:
          messages.append('missing field')
        else:
          # Are there any different values?
          if value_1 != value_2:
            messages.append('different values')
      # Are there any extra fields?
      for field in field_map_2:
        if field not in field_map_1:
          messages.append('extra field')
  # Are there any extra records?
  for record in records_2:
    if record not in records_1:
      messages.append('extra record')

def pfif_file_diff(file_1, file_2):
  """Compares file_1 and file_2.  Returns a list of messages as per
  pfif_obj_diff."""
  records_1 = objectify_pfif_xml(file_1)
  records_2 = objectify_pfif_xml(file_2)
  return pfif_obj_diff(records_1, records_2)

# def output_diff(self, messages):
  # Output the Diff
